////  CSE274 SECTION C - DR. HE//  ETHAN GUTKNECHT 9/4/2020 - 4:09pm EST//import java.util.Arrays;import java.util.EmptyStackException;public final class LinkedStack<T> implements StackInterface<T> {	private Node topNode; // References the first node in the chain		public LinkedStack() {		topNode = null;	} // end default constructor				@Override //returns the size of the stack	public int size() {		// TODO Auto-generated method stub		return 0;	}				//PUSH - ADD NEW NODE TO TOP	public void push(int newEntry) {		Node newNode = new Node(newEntry);		if (topNode == null) {			topNode = newNode;		}		else {			newNode.setNextNode(topNode);			topNode = newNode;		}	} // end push			//Peak - RETURNS DATA OF NODE ON TOP	public int peek() { 		if (isEmpty()) throw new EmptyStackException();		else return topNode.getData();	}				//POP - REMOVES FROM THE TOP OF THE STACK	public int pop() throws StackEmptyException {		if (topNode == null) throw new StackEmptyException();		int result = topNode.data;		topNode = topNode.getNextNode(); //remove top, replace with one following it		return result;	} // end pop			//EMPTY - CHECKS IF STACK IS EMPTY	public boolean isEmpty() {		return topNode == null;	} // end isEmpty				//CLEAR - LIST	public void clear() {		topNode = null;	} // end clear		/** Computes the sum of all the numbers in the stack. For example, the stack has 4 data entries: is 1 2 3 4 (1 is the top), the output of sum() is 1+2+3+4 */	public int sum() {		if (topNode == null) return 0;		else return sumRecursion(topNode);	}				//recurring sum method	private int sumRecursion (Node input) {		if (input == null) return 0;		else return input.getData() + sumRecursion(input.getNextNode());	}				/*	 * Computes the sum of all the numbers in the stack. However, if two or more	 * numbers in a row are equal, only add one of them. So, for example, if the	 * stack contained 4, 1, 2, 2, 7, 2, 8, 8, 8, 4, then the numbers that would	 * be added would be 4 + 1 + 2 + 7 + 2 + 8 + 4 = 28. Here 4 is the top of the stack.	 */	public int sumSkipDu() {		if (isEmpty()) return 0;		else if (topNode.getNextNode() == null) return topNode.getData();		else return topNode.getData() + sumSkipDuRecursion(topNode, topNode.getNextNode());	}		private int sumSkipDuRecursion (Node previousinput, Node newinput) {		//returns zero at end		if (newinput == null) return 0;		//if previous input and current input are equal it will not add the value		else if (previousinput.getData() == newinput.getData())  			return sumSkipDuRecursion(newinput, newinput.getNextNode());				//if they are not equal it will add the value		else return newinput.getData() + sumSkipDuRecursion(newinput, newinput.getNextNode()); 	}			    /*     * A Palindrome reads the same forward and backward. For example, 12321 is a Palindrome, 257494752 is also a Palindrome. Use a stack to determine if a given string is a palindrome.      */    public boolean isPalindrome(int[] inputInteger) {    	for (int i = 0; i < (inputInteger.length / 2) + 1; i++) {    		if (inputInteger[i] != inputInteger[inputInteger.length - i - 1]) return false;    	}    	return true; //if nothing fails then true    }                //node constructors and methods	private class Node {		private int data; // Entry in bag		private Node next;				private Node(int dataPortion) {			this(dataPortion, null);		}				//A node that returns an int.		public int getData() {			return this.data;		}		//A node that returns the following link		public Node getNextNode() {			return next;		}				//set data		public void setData(int inputdata) {			data = inputdata;		}		//Set next node		public void setNextNode(Node inputnode) {			next = inputnode;		}				//node constructor		private Node(int dataPortion, Node nextNode) {			data = dataPortion;			next = nextNode;		}	} // end Node} // end LinkedStack